// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod math {
        pub mod vec {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod vec2 {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                /// 2D vector using floats
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec2F32 {
                    pub x: f32,
                    pub y: f32,
                }
                impl ::core::fmt::Debug for Vec2F32 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec2F32")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec2F64 {
                    pub x: f64,
                    pub y: f64,
                }
                impl ::core::fmt::Debug for Vec2F64 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec2F64")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .finish()
                    }
                }
                /// 2D vector using signed integers
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec2S8 {
                    pub x: i8,
                    pub y: i8,
                }
                impl ::core::fmt::Debug for Vec2S8 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec2S8")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec2S16 {
                    pub x: i16,
                    pub y: i16,
                }
                impl ::core::fmt::Debug for Vec2S16 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec2S16")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec2S32 {
                    pub x: i32,
                    pub y: i32,
                }
                impl ::core::fmt::Debug for Vec2S32 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec2S32")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec2S64 {
                    pub x: i64,
                    pub y: i64,
                }
                impl ::core::fmt::Debug for Vec2S64 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec2S64")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .finish()
                    }
                }
                /// 2D vector using unsigned integers
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec2U8 {
                    pub x: u8,
                    pub y: u8,
                }
                impl ::core::fmt::Debug for Vec2U8 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec2U8")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec2U16 {
                    pub x: u16,
                    pub y: u16,
                }
                impl ::core::fmt::Debug for Vec2U16 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec2U16")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec2U32 {
                    pub x: u32,
                    pub y: u32,
                }
                impl ::core::fmt::Debug for Vec2U32 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec2U32")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec2U64 {
                    pub x: u64,
                    pub y: u64,
                }
                impl ::core::fmt::Debug for Vec2U64 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec2U64")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_float32_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::float32();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec2F32 { x: x2, y: y2 } = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(x2);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(y2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_float64_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::float64();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec2F64 { x: x2, y: y2 } = result0;
                    *ptr1.add(0).cast::<f64>() = _rt::as_f64(x2);
                    *ptr1.add(8).cast::<f64>() = _rt::as_f64(y2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int8_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int8();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec2S8 { x: x2, y: y2 } = result0;
                    *ptr1.add(0).cast::<u8>() = (_rt::as_i32(x2)) as u8;
                    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(y2)) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int16_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int16();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec2S16 { x: x2, y: y2 } = result0;
                    *ptr1.add(0).cast::<u16>() = (_rt::as_i32(x2)) as u16;
                    *ptr1.add(2).cast::<u16>() = (_rt::as_i32(y2)) as u16;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int32_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int32();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec2S32 { x: x2, y: y2 } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(x2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(y2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int64_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int64();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec2S64 { x: x2, y: y2 } = result0;
                    *ptr1.add(0).cast::<i64>() = _rt::as_i64(x2);
                    *ptr1.add(8).cast::<i64>() = _rt::as_i64(y2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint8_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint8();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec2U8 { x: x2, y: y2 } = result0;
                    *ptr1.add(0).cast::<u8>() = (_rt::as_i32(x2)) as u8;
                    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(y2)) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint16_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint16();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec2U16 { x: x2, y: y2 } = result0;
                    *ptr1.add(0).cast::<u16>() = (_rt::as_i32(x2)) as u16;
                    *ptr1.add(2).cast::<u16>() = (_rt::as_i32(y2)) as u16;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint32_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint32();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec2U32 { x: x2, y: y2 } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(x2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(y2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint64_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint64();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec2U64 { x: x2, y: y2 } = result0;
                    *ptr1.add(0).cast::<i64>() = _rt::as_i64(x2);
                    *ptr1.add(8).cast::<i64>() = _rt::as_i64(y2);
                    ptr1
                }
                pub trait Guest {
                    /// Constructors for vec2
                    fn float32() -> Vec2F32;
                    fn float64() -> Vec2F64;
                    fn int8() -> Vec2S8;
                    fn int16() -> Vec2S16;
                    fn int32() -> Vec2S32;
                    fn int64() -> Vec2S64;
                    fn uint8() -> Vec2U8;
                    fn uint16() -> Vec2U16;
                    fn uint32() -> Vec2U32;
                    fn uint64() -> Vec2U64;
                }
                #[doc(hidden)]
                macro_rules! __export_math_vec_vec2_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "math:vec/vec2@0.1.0#float32")] unsafe extern "C" fn
                        export_float32() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_float32_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec2@0.1.0#float64")] unsafe extern "C" fn
                        export_float64() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_float64_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec2@0.1.0#int8")] unsafe extern "C" fn export_int8()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int8_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec2@0.1.0#int16")] unsafe extern "C" fn export_int16()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int16_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec2@0.1.0#int32")] unsafe extern "C" fn export_int32()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int32_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec2@0.1.0#int64")] unsafe extern "C" fn export_int64()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int64_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec2@0.1.0#uint8")] unsafe extern "C" fn export_uint8()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint8_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec2@0.1.0#uint16")] unsafe extern "C" fn
                        export_uint16() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint16_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec2@0.1.0#uint32")] unsafe extern "C" fn
                        export_uint32() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint32_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec2@0.1.0#uint64")] unsafe extern "C" fn
                        export_uint64() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint64_cabi::<$ty > () } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_math_vec_vec2_0_1_0_cabi;
                #[repr(align(8))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 16],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod vec3 {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                /// 3D vector using floats
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec3F32 {
                    pub x: f32,
                    pub y: f32,
                    pub z: f32,
                }
                impl ::core::fmt::Debug for Vec3F32 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec3F32")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec3F64 {
                    pub x: f64,
                    pub y: f64,
                    pub z: f64,
                }
                impl ::core::fmt::Debug for Vec3F64 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec3F64")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .finish()
                    }
                }
                /// 3D vector using signed integers
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec3S8 {
                    pub x: i8,
                    pub y: i8,
                    pub z: i8,
                }
                impl ::core::fmt::Debug for Vec3S8 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec3S8")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec3S16 {
                    pub x: i16,
                    pub y: i16,
                    pub z: i16,
                }
                impl ::core::fmt::Debug for Vec3S16 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec3S16")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec3S32 {
                    pub x: i32,
                    pub y: i32,
                    pub z: i32,
                }
                impl ::core::fmt::Debug for Vec3S32 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec3S32")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec3S64 {
                    pub x: i64,
                    pub y: i64,
                    pub z: i64,
                }
                impl ::core::fmt::Debug for Vec3S64 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec3S64")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .finish()
                    }
                }
                /// 3D vector using unsigned integers
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec3U8 {
                    pub x: u8,
                    pub y: u8,
                    pub z: u8,
                }
                impl ::core::fmt::Debug for Vec3U8 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec3U8")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec3U16 {
                    pub x: u16,
                    pub y: u16,
                    pub z: u16,
                }
                impl ::core::fmt::Debug for Vec3U16 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec3U16")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec3U32 {
                    pub x: u32,
                    pub y: u32,
                    pub z: u32,
                }
                impl ::core::fmt::Debug for Vec3U32 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec3U32")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec3U64 {
                    pub x: u64,
                    pub y: u64,
                    pub z: u64,
                }
                impl ::core::fmt::Debug for Vec3U64 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec3U64")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_float32_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::float32();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec3F32 { x: x2, y: y2, z: z2 } = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(x2);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(y2);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(z2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_float64_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::float64();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec3F64 { x: x2, y: y2, z: z2 } = result0;
                    *ptr1.add(0).cast::<f64>() = _rt::as_f64(x2);
                    *ptr1.add(8).cast::<f64>() = _rt::as_f64(y2);
                    *ptr1.add(16).cast::<f64>() = _rt::as_f64(z2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int8_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int8();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec3S8 { x: x2, y: y2, z: z2 } = result0;
                    *ptr1.add(0).cast::<u8>() = (_rt::as_i32(x2)) as u8;
                    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(y2)) as u8;
                    *ptr1.add(2).cast::<u8>() = (_rt::as_i32(z2)) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int16_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int16();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec3S16 { x: x2, y: y2, z: z2 } = result0;
                    *ptr1.add(0).cast::<u16>() = (_rt::as_i32(x2)) as u16;
                    *ptr1.add(2).cast::<u16>() = (_rt::as_i32(y2)) as u16;
                    *ptr1.add(4).cast::<u16>() = (_rt::as_i32(z2)) as u16;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int32_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int32();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec3S32 { x: x2, y: y2, z: z2 } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(x2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(y2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(z2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int64_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int64();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec3S64 { x: x2, y: y2, z: z2 } = result0;
                    *ptr1.add(0).cast::<i64>() = _rt::as_i64(x2);
                    *ptr1.add(8).cast::<i64>() = _rt::as_i64(y2);
                    *ptr1.add(16).cast::<i64>() = _rt::as_i64(z2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint8_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint8();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec3U8 { x: x2, y: y2, z: z2 } = result0;
                    *ptr1.add(0).cast::<u8>() = (_rt::as_i32(x2)) as u8;
                    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(y2)) as u8;
                    *ptr1.add(2).cast::<u8>() = (_rt::as_i32(z2)) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint16_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint16();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec3U16 { x: x2, y: y2, z: z2 } = result0;
                    *ptr1.add(0).cast::<u16>() = (_rt::as_i32(x2)) as u16;
                    *ptr1.add(2).cast::<u16>() = (_rt::as_i32(y2)) as u16;
                    *ptr1.add(4).cast::<u16>() = (_rt::as_i32(z2)) as u16;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint32_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint32();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec3U32 { x: x2, y: y2, z: z2 } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(x2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(y2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(z2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint64_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint64();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec3U64 { x: x2, y: y2, z: z2 } = result0;
                    *ptr1.add(0).cast::<i64>() = _rt::as_i64(x2);
                    *ptr1.add(8).cast::<i64>() = _rt::as_i64(y2);
                    *ptr1.add(16).cast::<i64>() = _rt::as_i64(z2);
                    ptr1
                }
                pub trait Guest {
                    /// Constructors for vec3
                    fn float32() -> Vec3F32;
                    fn float64() -> Vec3F64;
                    fn int8() -> Vec3S8;
                    fn int16() -> Vec3S16;
                    fn int32() -> Vec3S32;
                    fn int64() -> Vec3S64;
                    fn uint8() -> Vec3U8;
                    fn uint16() -> Vec3U16;
                    fn uint32() -> Vec3U32;
                    fn uint64() -> Vec3U64;
                }
                #[doc(hidden)]
                macro_rules! __export_math_vec_vec3_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "math:vec/vec3@0.1.0#float32")] unsafe extern "C" fn
                        export_float32() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_float32_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec3@0.1.0#float64")] unsafe extern "C" fn
                        export_float64() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_float64_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec3@0.1.0#int8")] unsafe extern "C" fn export_int8()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int8_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec3@0.1.0#int16")] unsafe extern "C" fn export_int16()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int16_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec3@0.1.0#int32")] unsafe extern "C" fn export_int32()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int32_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec3@0.1.0#int64")] unsafe extern "C" fn export_int64()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int64_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec3@0.1.0#uint8")] unsafe extern "C" fn export_uint8()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint8_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec3@0.1.0#uint16")] unsafe extern "C" fn
                        export_uint16() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint16_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec3@0.1.0#uint32")] unsafe extern "C" fn
                        export_uint32() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint32_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec3@0.1.0#uint64")] unsafe extern "C" fn
                        export_uint64() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint64_cabi::<$ty > () } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_math_vec_vec3_0_1_0_cabi;
                #[repr(align(8))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 24],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod vec4 {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                /// 4D vector using floats
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec4F32 {
                    pub x: f32,
                    pub y: f32,
                    pub z: f32,
                    pub w: f32,
                }
                impl ::core::fmt::Debug for Vec4F32 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec4F32")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .field("w", &self.w)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec4F64 {
                    pub x: f64,
                    pub y: f64,
                    pub z: f64,
                    pub w: f64,
                }
                impl ::core::fmt::Debug for Vec4F64 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec4F64")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .field("w", &self.w)
                            .finish()
                    }
                }
                /// 4D vector using signed integers
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec4S8 {
                    pub x: i8,
                    pub y: i8,
                    pub z: i8,
                    pub w: i8,
                }
                impl ::core::fmt::Debug for Vec4S8 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec4S8")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .field("w", &self.w)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec4S16 {
                    pub x: i16,
                    pub y: i16,
                    pub z: i16,
                    pub w: i16,
                }
                impl ::core::fmt::Debug for Vec4S16 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec4S16")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .field("w", &self.w)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec4S32 {
                    pub x: i32,
                    pub y: i32,
                    pub z: i32,
                    pub w: i32,
                }
                impl ::core::fmt::Debug for Vec4S32 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec4S32")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .field("w", &self.w)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec4S64 {
                    pub x: i64,
                    pub y: i64,
                    pub z: i64,
                    pub w: i64,
                }
                impl ::core::fmt::Debug for Vec4S64 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec4S64")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .field("w", &self.w)
                            .finish()
                    }
                }
                /// 4D vector using unsigned integers
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec4U8 {
                    pub x: u8,
                    pub y: u8,
                    pub z: u8,
                    pub w: u8,
                }
                impl ::core::fmt::Debug for Vec4U8 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec4U8")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .field("w", &self.w)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec4U16 {
                    pub x: u16,
                    pub y: u16,
                    pub z: u16,
                    pub w: u16,
                }
                impl ::core::fmt::Debug for Vec4U16 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec4U16")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .field("w", &self.w)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec4U32 {
                    pub x: u32,
                    pub y: u32,
                    pub z: u32,
                    pub w: u32,
                }
                impl ::core::fmt::Debug for Vec4U32 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec4U32")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .field("w", &self.w)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Vec4U64 {
                    pub x: u64,
                    pub y: u64,
                    pub z: u64,
                    pub w: u64,
                }
                impl ::core::fmt::Debug for Vec4U64 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Vec4U64")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .field("z", &self.z)
                            .field("w", &self.w)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_float32_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::float32();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec4F32 { x: x2, y: y2, z: z2, w: w2 } = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(x2);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(y2);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(z2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(w2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_float64_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::float64();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec4F64 { x: x2, y: y2, z: z2, w: w2 } = result0;
                    *ptr1.add(0).cast::<f64>() = _rt::as_f64(x2);
                    *ptr1.add(8).cast::<f64>() = _rt::as_f64(y2);
                    *ptr1.add(16).cast::<f64>() = _rt::as_f64(z2);
                    *ptr1.add(24).cast::<f64>() = _rt::as_f64(w2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int8_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int8();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec4S8 { x: x2, y: y2, z: z2, w: w2 } = result0;
                    *ptr1.add(0).cast::<u8>() = (_rt::as_i32(x2)) as u8;
                    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(y2)) as u8;
                    *ptr1.add(2).cast::<u8>() = (_rt::as_i32(z2)) as u8;
                    *ptr1.add(3).cast::<u8>() = (_rt::as_i32(w2)) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int16_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int16();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec4S16 { x: x2, y: y2, z: z2, w: w2 } = result0;
                    *ptr1.add(0).cast::<u16>() = (_rt::as_i32(x2)) as u16;
                    *ptr1.add(2).cast::<u16>() = (_rt::as_i32(y2)) as u16;
                    *ptr1.add(4).cast::<u16>() = (_rt::as_i32(z2)) as u16;
                    *ptr1.add(6).cast::<u16>() = (_rt::as_i32(w2)) as u16;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int32_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int32();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec4S32 { x: x2, y: y2, z: z2, w: w2 } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(x2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(y2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(z2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(w2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_int64_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::int64();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec4S64 { x: x2, y: y2, z: z2, w: w2 } = result0;
                    *ptr1.add(0).cast::<i64>() = _rt::as_i64(x2);
                    *ptr1.add(8).cast::<i64>() = _rt::as_i64(y2);
                    *ptr1.add(16).cast::<i64>() = _rt::as_i64(z2);
                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(w2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint8_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint8();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec4U8 { x: x2, y: y2, z: z2, w: w2 } = result0;
                    *ptr1.add(0).cast::<u8>() = (_rt::as_i32(x2)) as u8;
                    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(y2)) as u8;
                    *ptr1.add(2).cast::<u8>() = (_rt::as_i32(z2)) as u8;
                    *ptr1.add(3).cast::<u8>() = (_rt::as_i32(w2)) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint16_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint16();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec4U16 { x: x2, y: y2, z: z2, w: w2 } = result0;
                    *ptr1.add(0).cast::<u16>() = (_rt::as_i32(x2)) as u16;
                    *ptr1.add(2).cast::<u16>() = (_rt::as_i32(y2)) as u16;
                    *ptr1.add(4).cast::<u16>() = (_rt::as_i32(z2)) as u16;
                    *ptr1.add(6).cast::<u16>() = (_rt::as_i32(w2)) as u16;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint32_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint32();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec4U32 { x: x2, y: y2, z: z2, w: w2 } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(x2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(y2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(z2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(w2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_uint64_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::uint64();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Vec4U64 { x: x2, y: y2, z: z2, w: w2 } = result0;
                    *ptr1.add(0).cast::<i64>() = _rt::as_i64(x2);
                    *ptr1.add(8).cast::<i64>() = _rt::as_i64(y2);
                    *ptr1.add(16).cast::<i64>() = _rt::as_i64(z2);
                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(w2);
                    ptr1
                }
                pub trait Guest {
                    /// Constructors
                    fn float32() -> Vec4F32;
                    fn float64() -> Vec4F64;
                    fn int8() -> Vec4S8;
                    fn int16() -> Vec4S16;
                    fn int32() -> Vec4S32;
                    fn int64() -> Vec4S64;
                    fn uint8() -> Vec4U8;
                    fn uint16() -> Vec4U16;
                    fn uint32() -> Vec4U32;
                    fn uint64() -> Vec4U64;
                }
                #[doc(hidden)]
                macro_rules! __export_math_vec_vec4_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "math:vec/vec4@0.1.0#float32")] unsafe extern "C" fn
                        export_float32() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_float32_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec4@0.1.0#float64")] unsafe extern "C" fn
                        export_float64() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_float64_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec4@0.1.0#int8")] unsafe extern "C" fn export_int8()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int8_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec4@0.1.0#int16")] unsafe extern "C" fn export_int16()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int16_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec4@0.1.0#int32")] unsafe extern "C" fn export_int32()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int32_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec4@0.1.0#int64")] unsafe extern "C" fn export_int64()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_int64_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec4@0.1.0#uint8")] unsafe extern "C" fn export_uint8()
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint8_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec4@0.1.0#uint16")] unsafe extern "C" fn
                        export_uint16() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint16_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec4@0.1.0#uint32")] unsafe extern "C" fn
                        export_uint32() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint32_cabi::<$ty > () } } #[unsafe (export_name =
                        "math:vec/vec4@0.1.0#uint64")] unsafe extern "C" fn
                        export_uint64() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_uint64_cabi::<$ty > () } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_math_vec_vec4_0_1_0_cabi;
                #[repr(align(8))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 32],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }
    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }
    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }
    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
    pub fn as_f64<T: AsF64>(t: T) -> f64 {
        t.as_f64()
    }
    pub trait AsF64 {
        fn as_f64(self) -> f64;
    }
    impl<'a, T: Copy + AsF64> AsF64 for &'a T {
        fn as_f64(self) -> f64 {
            (*self).as_f64()
        }
    }
    impl AsF64 for f64 {
        #[inline]
        fn as_f64(self) -> f64 {
            self as f64
        }
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_types_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::math::vec::vec2::__export_math_vec_vec2_0_1_0_cabi!($ty with_types_in
        $($path_to_types_root)*:: exports::math::vec::vec2); $($path_to_types_root)*::
        exports::math::vec::vec3::__export_math_vec_vec3_0_1_0_cabi!($ty with_types_in
        $($path_to_types_root)*:: exports::math::vec::vec3); $($path_to_types_root)*::
        exports::math::vec::vec4::__export_math_vec_vec4_0_1_0_cabi!($ty with_types_in
        $($path_to_types_root)*:: exports::math::vec::vec4);
    };
}
#[doc(inline)]
pub(crate) use __export_types_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:math:vec@0.1.0:types:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1478] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xca\x0a\x01A\x02\x01\
A\x06\x01B(\x01r\x02\x01xv\x01yv\x04\0\x08vec2-f32\x03\0\0\x01r\x02\x01xu\x01yu\x04\
\0\x08vec2-f64\x03\0\x02\x01r\x02\x01x~\x01y~\x04\0\x07vec2-s8\x03\0\x04\x01r\x02\
\x01x|\x01y|\x04\0\x08vec2-s16\x03\0\x06\x01r\x02\x01xz\x01yz\x04\0\x08vec2-s32\x03\
\0\x08\x01r\x02\x01xx\x01yx\x04\0\x08vec2-s64\x03\0\x0a\x01r\x02\x01x}\x01y}\x04\
\0\x07vec2-u8\x03\0\x0c\x01r\x02\x01x{\x01y{\x04\0\x08vec2-u16\x03\0\x0e\x01r\x02\
\x01xy\x01yy\x04\0\x08vec2-u32\x03\0\x10\x01r\x02\x01xw\x01yw\x04\0\x08vec2-u64\x03\
\0\x12\x01@\0\0\x01\x04\0\x07float32\x01\x14\x01@\0\0\x03\x04\0\x07float64\x01\x15\
\x01@\0\0\x05\x04\0\x04int8\x01\x16\x01@\0\0\x07\x04\0\x05int16\x01\x17\x01@\0\0\
\x09\x04\0\x05int32\x01\x18\x01@\0\0\x0b\x04\0\x05int64\x01\x19\x01@\0\0\x0d\x04\
\0\x05uint8\x01\x1a\x01@\0\0\x0f\x04\0\x06uint16\x01\x1b\x01@\0\0\x11\x04\0\x06u\
int32\x01\x1c\x01@\0\0\x13\x04\0\x06uint64\x01\x1d\x04\0\x13math:vec/vec2@0.1.0\x05\
\0\x01B(\x01r\x03\x01xv\x01yv\x01zv\x04\0\x08vec3-f32\x03\0\0\x01r\x03\x01xu\x01\
yu\x01zu\x04\0\x08vec3-f64\x03\0\x02\x01r\x03\x01x~\x01y~\x01z~\x04\0\x07vec3-s8\
\x03\0\x04\x01r\x03\x01x|\x01y|\x01z|\x04\0\x08vec3-s16\x03\0\x06\x01r\x03\x01xz\
\x01yz\x01zz\x04\0\x08vec3-s32\x03\0\x08\x01r\x03\x01xx\x01yx\x01zx\x04\0\x08vec\
3-s64\x03\0\x0a\x01r\x03\x01x}\x01y}\x01z}\x04\0\x07vec3-u8\x03\0\x0c\x01r\x03\x01\
x{\x01y{\x01z{\x04\0\x08vec3-u16\x03\0\x0e\x01r\x03\x01xy\x01yy\x01zy\x04\0\x08v\
ec3-u32\x03\0\x10\x01r\x03\x01xw\x01yw\x01zw\x04\0\x08vec3-u64\x03\0\x12\x01@\0\0\
\x01\x04\0\x07float32\x01\x14\x01@\0\0\x03\x04\0\x07float64\x01\x15\x01@\0\0\x05\
\x04\0\x04int8\x01\x16\x01@\0\0\x07\x04\0\x05int16\x01\x17\x01@\0\0\x09\x04\0\x05\
int32\x01\x18\x01@\0\0\x0b\x04\0\x05int64\x01\x19\x01@\0\0\x0d\x04\0\x05uint8\x01\
\x1a\x01@\0\0\x0f\x04\0\x06uint16\x01\x1b\x01@\0\0\x11\x04\0\x06uint32\x01\x1c\x01\
@\0\0\x13\x04\0\x06uint64\x01\x1d\x04\0\x13math:vec/vec3@0.1.0\x05\x01\x01B(\x01\
r\x04\x01xv\x01yv\x01zv\x01wv\x04\0\x08vec4-f32\x03\0\0\x01r\x04\x01xu\x01yu\x01\
zu\x01wu\x04\0\x08vec4-f64\x03\0\x02\x01r\x04\x01x~\x01y~\x01z~\x01w~\x04\0\x07v\
ec4-s8\x03\0\x04\x01r\x04\x01x|\x01y|\x01z|\x01w|\x04\0\x08vec4-s16\x03\0\x06\x01\
r\x04\x01xz\x01yz\x01zz\x01wz\x04\0\x08vec4-s32\x03\0\x08\x01r\x04\x01xx\x01yx\x01\
zx\x01wx\x04\0\x08vec4-s64\x03\0\x0a\x01r\x04\x01x}\x01y}\x01z}\x01w}\x04\0\x07v\
ec4-u8\x03\0\x0c\x01r\x04\x01x{\x01y{\x01z{\x01w{\x04\0\x08vec4-u16\x03\0\x0e\x01\
r\x04\x01xy\x01yy\x01zy\x01wy\x04\0\x08vec4-u32\x03\0\x10\x01r\x04\x01xw\x01yw\x01\
zw\x01ww\x04\0\x08vec4-u64\x03\0\x12\x01@\0\0\x01\x04\0\x07float32\x01\x14\x01@\0\
\0\x03\x04\0\x07float64\x01\x15\x01@\0\0\x05\x04\0\x04int8\x01\x16\x01@\0\0\x07\x04\
\0\x05int16\x01\x17\x01@\0\0\x09\x04\0\x05int32\x01\x18\x01@\0\0\x0b\x04\0\x05in\
t64\x01\x19\x01@\0\0\x0d\x04\0\x05uint8\x01\x1a\x01@\0\0\x0f\x04\0\x06uint16\x01\
\x1b\x01@\0\0\x11\x04\0\x06uint32\x01\x1c\x01@\0\0\x13\x04\0\x06uint64\x01\x1d\x04\
\0\x13math:vec/vec4@0.1.0\x05\x02\x04\0\x14math:vec/types@0.1.0\x04\0\x0b\x0b\x01\
\0\x05types\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x07\
0.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
