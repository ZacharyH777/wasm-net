// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod math {
    pub mod vec {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod vec2 {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            /// 2D vector using floats
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec2F32 {
                pub x: f32,
                pub y: f32,
            }
            impl ::core::fmt::Debug for Vec2F32 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec2F32")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec2F64 {
                pub x: f64,
                pub y: f64,
            }
            impl ::core::fmt::Debug for Vec2F64 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec2F64")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .finish()
                }
            }
            /// 2D vector using signed integers
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec2S8 {
                pub x: i8,
                pub y: i8,
            }
            impl ::core::fmt::Debug for Vec2S8 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec2S8")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec2S16 {
                pub x: i16,
                pub y: i16,
            }
            impl ::core::fmt::Debug for Vec2S16 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec2S16")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec2S32 {
                pub x: i32,
                pub y: i32,
            }
            impl ::core::fmt::Debug for Vec2S32 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec2S32")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec2S64 {
                pub x: i64,
                pub y: i64,
            }
            impl ::core::fmt::Debug for Vec2S64 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec2S64")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .finish()
                }
            }
            /// 2D vector using unsigned integers
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec2U8 {
                pub x: u8,
                pub y: u8,
            }
            impl ::core::fmt::Debug for Vec2U8 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec2U8")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec2U16 {
                pub x: u16,
                pub y: u16,
            }
            impl ::core::fmt::Debug for Vec2U16 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec2U16")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec2U32 {
                pub x: u32,
                pub y: u32,
            }
            impl ::core::fmt::Debug for Vec2U32 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec2U32")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec2U64 {
                pub x: u64,
                pub y: u64,
            }
            impl ::core::fmt::Debug for Vec2U64 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec2U64")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Constructors for vec2
            pub fn float32() -> Vec2F32 {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec2@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "float32"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<f32>();
                    let l3 = *ptr0.add(4).cast::<f32>();
                    let result4 = Vec2F32 { x: l2, y: l3 };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn float64() -> Vec2F64 {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec2@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "float64"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<f64>();
                    let l3 = *ptr0.add(8).cast::<f64>();
                    let result4 = Vec2F64 { x: l2, y: l3 };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int8() -> Vec2S8 {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec2@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int8"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<i8>());
                    let l3 = i32::from(*ptr0.add(1).cast::<i8>());
                    let result4 = Vec2S8 { x: l2 as i8, y: l3 as i8 };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int16() -> Vec2S16 {
                unsafe {
                    #[repr(align(2))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 4]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec2@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int16"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<i16>());
                    let l3 = i32::from(*ptr0.add(2).cast::<i16>());
                    let result4 = Vec2S16 {
                        x: l2 as i16,
                        y: l3 as i16,
                    };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int32() -> Vec2S32 {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec2@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int32"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i32>();
                    let l3 = *ptr0.add(4).cast::<i32>();
                    let result4 = Vec2S32 { x: l2, y: l3 };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int64() -> Vec2S64 {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec2@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int64"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let result4 = Vec2S64 { x: l2, y: l3 };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint8() -> Vec2U8 {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec2@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint8"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                    let result4 = Vec2U8 { x: l2 as u8, y: l3 as u8 };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint16() -> Vec2U16 {
                unsafe {
                    #[repr(align(2))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 4]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec2@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint16"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u16>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u16>());
                    let result4 = Vec2U16 {
                        x: l2 as u16,
                        y: l3 as u16,
                    };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint32() -> Vec2U32 {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec2@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint32"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i32>();
                    let l3 = *ptr0.add(4).cast::<i32>();
                    let result4 = Vec2U32 {
                        x: l2 as u32,
                        y: l3 as u32,
                    };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint64() -> Vec2U64 {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec2@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint64"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let result4 = Vec2U64 {
                        x: l2 as u64,
                        y: l3 as u64,
                    };
                    result4
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod vec3 {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            /// 3D vector using floats
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec3F32 {
                pub x: f32,
                pub y: f32,
                pub z: f32,
            }
            impl ::core::fmt::Debug for Vec3F32 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec3F32")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec3F64 {
                pub x: f64,
                pub y: f64,
                pub z: f64,
            }
            impl ::core::fmt::Debug for Vec3F64 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec3F64")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .finish()
                }
            }
            /// 3D vector using signed integers
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec3S8 {
                pub x: i8,
                pub y: i8,
                pub z: i8,
            }
            impl ::core::fmt::Debug for Vec3S8 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec3S8")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec3S16 {
                pub x: i16,
                pub y: i16,
                pub z: i16,
            }
            impl ::core::fmt::Debug for Vec3S16 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec3S16")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec3S32 {
                pub x: i32,
                pub y: i32,
                pub z: i32,
            }
            impl ::core::fmt::Debug for Vec3S32 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec3S32")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec3S64 {
                pub x: i64,
                pub y: i64,
                pub z: i64,
            }
            impl ::core::fmt::Debug for Vec3S64 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec3S64")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .finish()
                }
            }
            /// 3D vector using unsigned integers
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec3U8 {
                pub x: u8,
                pub y: u8,
                pub z: u8,
            }
            impl ::core::fmt::Debug for Vec3U8 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec3U8")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec3U16 {
                pub x: u16,
                pub y: u16,
                pub z: u16,
            }
            impl ::core::fmt::Debug for Vec3U16 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec3U16")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec3U32 {
                pub x: u32,
                pub y: u32,
                pub z: u32,
            }
            impl ::core::fmt::Debug for Vec3U32 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec3U32")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec3U64 {
                pub x: u64,
                pub y: u64,
                pub z: u64,
            }
            impl ::core::fmt::Debug for Vec3U64 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec3U64")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Constructors for vec3
            pub fn float32() -> Vec3F32 {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec3@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "float32"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<f32>();
                    let l3 = *ptr0.add(4).cast::<f32>();
                    let l4 = *ptr0.add(8).cast::<f32>();
                    let result5 = Vec3F32 { x: l2, y: l3, z: l4 };
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn float64() -> Vec3F64 {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec3@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "float64"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<f64>();
                    let l3 = *ptr0.add(8).cast::<f64>();
                    let l4 = *ptr0.add(16).cast::<f64>();
                    let result5 = Vec3F64 { x: l2, y: l3, z: l4 };
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int8() -> Vec3S8 {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 3]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec3@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int8"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<i8>());
                    let l3 = i32::from(*ptr0.add(1).cast::<i8>());
                    let l4 = i32::from(*ptr0.add(2).cast::<i8>());
                    let result5 = Vec3S8 {
                        x: l2 as i8,
                        y: l3 as i8,
                        z: l4 as i8,
                    };
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int16() -> Vec3S16 {
                unsafe {
                    #[repr(align(2))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 6]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 6]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec3@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int16"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<i16>());
                    let l3 = i32::from(*ptr0.add(2).cast::<i16>());
                    let l4 = i32::from(*ptr0.add(4).cast::<i16>());
                    let result5 = Vec3S16 {
                        x: l2 as i16,
                        y: l3 as i16,
                        z: l4 as i16,
                    };
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int32() -> Vec3S32 {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec3@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int32"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i32>();
                    let l3 = *ptr0.add(4).cast::<i32>();
                    let l4 = *ptr0.add(8).cast::<i32>();
                    let result5 = Vec3S32 { x: l2, y: l3, z: l4 };
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int64() -> Vec3S64 {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec3@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int64"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let l4 = *ptr0.add(16).cast::<i64>();
                    let result5 = Vec3S64 { x: l2, y: l3, z: l4 };
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint8() -> Vec3U8 {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 3]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec3@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint8"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l4 = i32::from(*ptr0.add(2).cast::<u8>());
                    let result5 = Vec3U8 {
                        x: l2 as u8,
                        y: l3 as u8,
                        z: l4 as u8,
                    };
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint16() -> Vec3U16 {
                unsafe {
                    #[repr(align(2))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 6]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 6]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec3@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint16"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u16>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u16>());
                    let l4 = i32::from(*ptr0.add(4).cast::<u16>());
                    let result5 = Vec3U16 {
                        x: l2 as u16,
                        y: l3 as u16,
                        z: l4 as u16,
                    };
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint32() -> Vec3U32 {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec3@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint32"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i32>();
                    let l3 = *ptr0.add(4).cast::<i32>();
                    let l4 = *ptr0.add(8).cast::<i32>();
                    let result5 = Vec3U32 {
                        x: l2 as u32,
                        y: l3 as u32,
                        z: l4 as u32,
                    };
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint64() -> Vec3U64 {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec3@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint64"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let l4 = *ptr0.add(16).cast::<i64>();
                    let result5 = Vec3U64 {
                        x: l2 as u64,
                        y: l3 as u64,
                        z: l4 as u64,
                    };
                    result5
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod vec4 {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            /// 4D vector using floats
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec4F32 {
                pub x: f32,
                pub y: f32,
                pub z: f32,
                pub w: f32,
            }
            impl ::core::fmt::Debug for Vec4F32 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec4F32")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .field("w", &self.w)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec4F64 {
                pub x: f64,
                pub y: f64,
                pub z: f64,
                pub w: f64,
            }
            impl ::core::fmt::Debug for Vec4F64 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec4F64")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .field("w", &self.w)
                        .finish()
                }
            }
            /// 4D vector using signed integers
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec4S8 {
                pub x: i8,
                pub y: i8,
                pub z: i8,
                pub w: i8,
            }
            impl ::core::fmt::Debug for Vec4S8 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec4S8")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .field("w", &self.w)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec4S16 {
                pub x: i16,
                pub y: i16,
                pub z: i16,
                pub w: i16,
            }
            impl ::core::fmt::Debug for Vec4S16 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec4S16")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .field("w", &self.w)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec4S32 {
                pub x: i32,
                pub y: i32,
                pub z: i32,
                pub w: i32,
            }
            impl ::core::fmt::Debug for Vec4S32 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec4S32")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .field("w", &self.w)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec4S64 {
                pub x: i64,
                pub y: i64,
                pub z: i64,
                pub w: i64,
            }
            impl ::core::fmt::Debug for Vec4S64 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec4S64")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .field("w", &self.w)
                        .finish()
                }
            }
            /// 4D vector using unsigned integers
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec4U8 {
                pub x: u8,
                pub y: u8,
                pub z: u8,
                pub w: u8,
            }
            impl ::core::fmt::Debug for Vec4U8 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec4U8")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .field("w", &self.w)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec4U16 {
                pub x: u16,
                pub y: u16,
                pub z: u16,
                pub w: u16,
            }
            impl ::core::fmt::Debug for Vec4U16 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec4U16")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .field("w", &self.w)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec4U32 {
                pub x: u32,
                pub y: u32,
                pub z: u32,
                pub w: u32,
            }
            impl ::core::fmt::Debug for Vec4U32 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec4U32")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .field("w", &self.w)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec4U64 {
                pub x: u64,
                pub y: u64,
                pub z: u64,
                pub w: u64,
            }
            impl ::core::fmt::Debug for Vec4U64 {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Vec4U64")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .field("w", &self.w)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Constructors
            pub fn float32() -> Vec4F32 {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec4@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "float32"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<f32>();
                    let l3 = *ptr0.add(4).cast::<f32>();
                    let l4 = *ptr0.add(8).cast::<f32>();
                    let l5 = *ptr0.add(12).cast::<f32>();
                    let result6 = Vec4F32 {
                        x: l2,
                        y: l3,
                        z: l4,
                        w: l5,
                    };
                    result6
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn float64() -> Vec4F64 {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 32]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec4@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "float64"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<f64>();
                    let l3 = *ptr0.add(8).cast::<f64>();
                    let l4 = *ptr0.add(16).cast::<f64>();
                    let l5 = *ptr0.add(24).cast::<f64>();
                    let result6 = Vec4F64 {
                        x: l2,
                        y: l3,
                        z: l4,
                        w: l5,
                    };
                    result6
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int8() -> Vec4S8 {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 4]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec4@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int8"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<i8>());
                    let l3 = i32::from(*ptr0.add(1).cast::<i8>());
                    let l4 = i32::from(*ptr0.add(2).cast::<i8>());
                    let l5 = i32::from(*ptr0.add(3).cast::<i8>());
                    let result6 = Vec4S8 {
                        x: l2 as i8,
                        y: l3 as i8,
                        z: l4 as i8,
                        w: l5 as i8,
                    };
                    result6
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int16() -> Vec4S16 {
                unsafe {
                    #[repr(align(2))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec4@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int16"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<i16>());
                    let l3 = i32::from(*ptr0.add(2).cast::<i16>());
                    let l4 = i32::from(*ptr0.add(4).cast::<i16>());
                    let l5 = i32::from(*ptr0.add(6).cast::<i16>());
                    let result6 = Vec4S16 {
                        x: l2 as i16,
                        y: l3 as i16,
                        z: l4 as i16,
                        w: l5 as i16,
                    };
                    result6
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int32() -> Vec4S32 {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec4@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int32"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i32>();
                    let l3 = *ptr0.add(4).cast::<i32>();
                    let l4 = *ptr0.add(8).cast::<i32>();
                    let l5 = *ptr0.add(12).cast::<i32>();
                    let result6 = Vec4S32 {
                        x: l2,
                        y: l3,
                        z: l4,
                        w: l5,
                    };
                    result6
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn int64() -> Vec4S64 {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 32]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec4@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "int64"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let l4 = *ptr0.add(16).cast::<i64>();
                    let l5 = *ptr0.add(24).cast::<i64>();
                    let result6 = Vec4S64 {
                        x: l2,
                        y: l3,
                        z: l4,
                        w: l5,
                    };
                    result6
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint8() -> Vec4U8 {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 4]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec4@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint8"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l4 = i32::from(*ptr0.add(2).cast::<u8>());
                    let l5 = i32::from(*ptr0.add(3).cast::<u8>());
                    let result6 = Vec4U8 {
                        x: l2 as u8,
                        y: l3 as u8,
                        z: l4 as u8,
                        w: l5 as u8,
                    };
                    result6
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint16() -> Vec4U16 {
                unsafe {
                    #[repr(align(2))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec4@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint16"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u16>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u16>());
                    let l4 = i32::from(*ptr0.add(4).cast::<u16>());
                    let l5 = i32::from(*ptr0.add(6).cast::<u16>());
                    let result6 = Vec4U16 {
                        x: l2 as u16,
                        y: l3 as u16,
                        z: l4 as u16,
                        w: l5 as u16,
                    };
                    result6
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint32() -> Vec4U32 {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec4@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint32"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i32>();
                    let l3 = *ptr0.add(4).cast::<i32>();
                    let l4 = *ptr0.add(8).cast::<i32>();
                    let l5 = *ptr0.add(12).cast::<i32>();
                    let result6 = Vec4U32 {
                        x: l2 as u32,
                        y: l3 as u32,
                        z: l4 as u32,
                        w: l5 as u32,
                    };
                    result6
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn uint64() -> Vec4U64 {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 32]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "math:vec/vec4@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "uint64"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let l4 = *ptr0.add(16).cast::<i64>();
                    let l5 = *ptr0.add(24).cast::<i64>();
                    let result6 = Vec4U64 {
                        x: l2 as u64,
                        y: l3 as u64,
                        z: l4 as u64,
                        w: l5 as u64,
                    };
                    result6
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod engine {
        pub mod components {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod transform {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Vec3F32 = super::super::super::super::math::vec::vec3::Vec3F32;
                pub type Vec4F32 = super::super::super::super::math::vec::vec4::Vec4F32;
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Transform3d {
                    pub position: Vec3F32,
                    pub rotation: Vec3F32,
                    pub quaterion: Vec4F32,
                    pub scale: Vec3F32,
                }
                impl ::core::fmt::Debug for Transform3d {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Transform3d")
                            .field("position", &self.position)
                            .field("rotation", &self.rotation)
                            .field("quaterion", &self.quaterion)
                            .field("scale", &self.scale)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_build3d_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::build3d();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let Transform3d {
                        position: position2,
                        rotation: rotation2,
                        quaterion: quaterion2,
                        scale: scale2,
                    } = result0;
                    let super::super::super::super::math::vec::vec3::Vec3F32 {
                        x: x3,
                        y: y3,
                        z: z3,
                    } = position2;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(x3);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(y3);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(z3);
                    let super::super::super::super::math::vec::vec3::Vec3F32 {
                        x: x4,
                        y: y4,
                        z: z4,
                    } = rotation2;
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(x4);
                    *ptr1.add(16).cast::<f32>() = _rt::as_f32(y4);
                    *ptr1.add(20).cast::<f32>() = _rt::as_f32(z4);
                    let super::super::super::super::math::vec::vec4::Vec4F32 {
                        x: x5,
                        y: y5,
                        z: z5,
                        w: w5,
                    } = quaterion2;
                    *ptr1.add(24).cast::<f32>() = _rt::as_f32(x5);
                    *ptr1.add(28).cast::<f32>() = _rt::as_f32(y5);
                    *ptr1.add(32).cast::<f32>() = _rt::as_f32(z5);
                    *ptr1.add(36).cast::<f32>() = _rt::as_f32(w5);
                    let super::super::super::super::math::vec::vec3::Vec3F32 {
                        x: x6,
                        y: y6,
                        z: z6,
                    } = scale2;
                    *ptr1.add(40).cast::<f32>() = _rt::as_f32(x6);
                    *ptr1.add(44).cast::<f32>() = _rt::as_f32(y6);
                    *ptr1.add(48).cast::<f32>() = _rt::as_f32(z6);
                    ptr1
                }
                pub trait Guest {
                    fn build3d() -> Transform3d;
                }
                #[doc(hidden)]
                macro_rules! __export_engine_components_transform_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "engine:components/transform@0.1.0#build3d")] unsafe extern "C"
                        fn export_build3d() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_build3d_cabi::<$ty > () } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_engine_components_transform_0_1_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 52]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 52],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }
    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }
    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }
    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_components_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::engine::components::transform::__export_engine_components_transform_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::engine::components::transform);
    };
}
#[doc(inline)]
pub(crate) use __export_components_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:engine:components@0.1.0:components:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1677] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x8c\x0c\x01A\x02\x01\
A\x0a\x01B(\x01r\x02\x01xv\x01yv\x04\0\x08vec2-f32\x03\0\0\x01r\x02\x01xu\x01yu\x04\
\0\x08vec2-f64\x03\0\x02\x01r\x02\x01x~\x01y~\x04\0\x07vec2-s8\x03\0\x04\x01r\x02\
\x01x|\x01y|\x04\0\x08vec2-s16\x03\0\x06\x01r\x02\x01xz\x01yz\x04\0\x08vec2-s32\x03\
\0\x08\x01r\x02\x01xx\x01yx\x04\0\x08vec2-s64\x03\0\x0a\x01r\x02\x01x}\x01y}\x04\
\0\x07vec2-u8\x03\0\x0c\x01r\x02\x01x{\x01y{\x04\0\x08vec2-u16\x03\0\x0e\x01r\x02\
\x01xy\x01yy\x04\0\x08vec2-u32\x03\0\x10\x01r\x02\x01xw\x01yw\x04\0\x08vec2-u64\x03\
\0\x12\x01@\0\0\x01\x04\0\x07float32\x01\x14\x01@\0\0\x03\x04\0\x07float64\x01\x15\
\x01@\0\0\x05\x04\0\x04int8\x01\x16\x01@\0\0\x07\x04\0\x05int16\x01\x17\x01@\0\0\
\x09\x04\0\x05int32\x01\x18\x01@\0\0\x0b\x04\0\x05int64\x01\x19\x01@\0\0\x0d\x04\
\0\x05uint8\x01\x1a\x01@\0\0\x0f\x04\0\x06uint16\x01\x1b\x01@\0\0\x11\x04\0\x06u\
int32\x01\x1c\x01@\0\0\x13\x04\0\x06uint64\x01\x1d\x03\0\x13math:vec/vec2@0.1.0\x05\
\0\x01B(\x01r\x03\x01xv\x01yv\x01zv\x04\0\x08vec3-f32\x03\0\0\x01r\x03\x01xu\x01\
yu\x01zu\x04\0\x08vec3-f64\x03\0\x02\x01r\x03\x01x~\x01y~\x01z~\x04\0\x07vec3-s8\
\x03\0\x04\x01r\x03\x01x|\x01y|\x01z|\x04\0\x08vec3-s16\x03\0\x06\x01r\x03\x01xz\
\x01yz\x01zz\x04\0\x08vec3-s32\x03\0\x08\x01r\x03\x01xx\x01yx\x01zx\x04\0\x08vec\
3-s64\x03\0\x0a\x01r\x03\x01x}\x01y}\x01z}\x04\0\x07vec3-u8\x03\0\x0c\x01r\x03\x01\
x{\x01y{\x01z{\x04\0\x08vec3-u16\x03\0\x0e\x01r\x03\x01xy\x01yy\x01zy\x04\0\x08v\
ec3-u32\x03\0\x10\x01r\x03\x01xw\x01yw\x01zw\x04\0\x08vec3-u64\x03\0\x12\x01@\0\0\
\x01\x04\0\x07float32\x01\x14\x01@\0\0\x03\x04\0\x07float64\x01\x15\x01@\0\0\x05\
\x04\0\x04int8\x01\x16\x01@\0\0\x07\x04\0\x05int16\x01\x17\x01@\0\0\x09\x04\0\x05\
int32\x01\x18\x01@\0\0\x0b\x04\0\x05int64\x01\x19\x01@\0\0\x0d\x04\0\x05uint8\x01\
\x1a\x01@\0\0\x0f\x04\0\x06uint16\x01\x1b\x01@\0\0\x11\x04\0\x06uint32\x01\x1c\x01\
@\0\0\x13\x04\0\x06uint64\x01\x1d\x03\0\x13math:vec/vec3@0.1.0\x05\x01\x01B(\x01\
r\x04\x01xv\x01yv\x01zv\x01wv\x04\0\x08vec4-f32\x03\0\0\x01r\x04\x01xu\x01yu\x01\
zu\x01wu\x04\0\x08vec4-f64\x03\0\x02\x01r\x04\x01x~\x01y~\x01z~\x01w~\x04\0\x07v\
ec4-s8\x03\0\x04\x01r\x04\x01x|\x01y|\x01z|\x01w|\x04\0\x08vec4-s16\x03\0\x06\x01\
r\x04\x01xz\x01yz\x01zz\x01wz\x04\0\x08vec4-s32\x03\0\x08\x01r\x04\x01xx\x01yx\x01\
zx\x01wx\x04\0\x08vec4-s64\x03\0\x0a\x01r\x04\x01x}\x01y}\x01z}\x01w}\x04\0\x07v\
ec4-u8\x03\0\x0c\x01r\x04\x01x{\x01y{\x01z{\x01w{\x04\0\x08vec4-u16\x03\0\x0e\x01\
r\x04\x01xy\x01yy\x01zy\x01wy\x04\0\x08vec4-u32\x03\0\x10\x01r\x04\x01xw\x01yw\x01\
zw\x01ww\x04\0\x08vec4-u64\x03\0\x12\x01@\0\0\x01\x04\0\x07float32\x01\x14\x01@\0\
\0\x03\x04\0\x07float64\x01\x15\x01@\0\0\x05\x04\0\x04int8\x01\x16\x01@\0\0\x07\x04\
\0\x05int16\x01\x17\x01@\0\0\x09\x04\0\x05int32\x01\x18\x01@\0\0\x0b\x04\0\x05in\
t64\x01\x19\x01@\0\0\x0d\x04\0\x05uint8\x01\x1a\x01@\0\0\x0f\x04\0\x06uint16\x01\
\x1b\x01@\0\0\x11\x04\0\x06uint32\x01\x1c\x01@\0\0\x13\x04\0\x06uint64\x01\x1d\x03\
\0\x13math:vec/vec4@0.1.0\x05\x02\x02\x03\0\x01\x08vec3-f32\x02\x03\0\x02\x08vec\
4-f32\x01B\x08\x02\x03\x02\x01\x03\x04\0\x08vec3-f32\x03\0\0\x02\x03\x02\x01\x04\
\x04\0\x08vec4-f32\x03\0\x02\x01r\x04\x08position\x01\x08rotation\x01\x09quateri\
on\x03\x05scale\x01\x04\0\x0btransform3d\x03\0\x04\x01@\0\0\x05\x04\0\x07build3d\
\x01\x06\x04\0!engine:components/transform@0.1.0\x05\x05\x04\0\"engine:component\
s/components@0.1.0\x04\0\x0b\x10\x01\0\x0acomponents\x03\0\0\0G\x09producers\x01\
\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
